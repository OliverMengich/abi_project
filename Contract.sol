
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract Bihashara {
    struct Proposal{
        string description;
        uint128 value;
        bool complete;
        uint approvalCount;
        mapping(address =>bool) approvals;
        address personLoan;
    }

    address public manager; // person requesting loan
    address public manager1;
    uint128 public minimumContribution=1000; // minimum monthly contributuon
    mapping(address =>bool) public members; // members
    address public bankAddress = address(0x60f4ccc4de4b67fc0b1299a2f2488c6fcc81c76f5ca4c83e6e3cfe12776c399a);

    Proposal[] proposals;
    uint public approversCount;

    uint32 public timestamp;
    event LoanApproved(string text,uint128 amount, uint32 timestamp);
    constructor() public {
        
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key

        require(msg.pubkey() ==tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();
        
    }
    modifier acceptMessage(){

        require(msg.pubkey() == tvm.pubkey(), 102);
        tvm.accept();
        _;
    }
    modifier restricted(){

        require(msg.pubkey() ==tvm.pubkey(),102);
        require(msg.sender == manager);
        tvm.accept();
        _;
    }
    function requestLoan(string description,uint128 value) public acceptMessage returns(Proposal){

        manager = msg.sender;
        Proposal newproposal = Proposal({
            description:description,
            value:value,
            complete:false,
            approvalCount:0,
            personLoan: manager
        });
        proposals.push(newproposal); //add new request to struct of requests
        return newproposal;
    }
    modifier onlyMembers(){
        require(msg.pubkey() == tvm.pubkey(), 102);
        require(members[msg.sender] == true);
        tvm.accept();
        _;
    }
    function addMembers(address newMember)public acceptMessage{
        require(members[newMember] ==false);
        members[newMember] =true;
    }
    function removeMembers(address oldmember) public onlyMembers{
        require(members[oldmember] ==true);
        members[oldmember] = false;

    }
    function approveLoan(uint index ) public view onlyMembers{
        Proposal propose = proposals[index];
        
        require(!propose.approvals[msg.sender]);// person hasn't approved contract before
        
        propose.approvals[msg.sender] = true;
        propose.approvalCount++; //append the value of approvers
    }
    function passLoan(uint index) public restricted{
        Proposal propose = proposals[index];
        require(propose.approvalCount > 10);

        require (!propose.complete);

        // if loan is approved we send request to bank 
        propose.complete=true;
        timestamp = now;
        string text = "Loan approved";
        emit LoanApproved(text,minimumContribution,timestamp);
    }
    function sendMonthlyContribution(uint128 amount,bool bounce) public view onlyMembers{
        require(amount > minimumContribution); // if Contributed amount is greater that the minimumContribution

        bankAddress.transfer(amount,bounce,3);
    }
    struct InsurePerson{
        bool isBusiness;
        mapping(address =>bool) passInsurance;
        uint agree;
        uint128 amount;
        bool complete;
        address personrequire;
    }
    InsurePerson[] insurance;

    function microInsurance(uint128 amount) public onlyMembers returns(InsurePerson){
        manager1 = msg.sender;
        InsurePerson newinsured = InsurePerson({
            isBusiness:true,
            complete:false,
            amount:amount,
            agree:0,
            personrequire: manager1
        });
        
        insurance.push(newinsured);
        return newinsured;
    }
    function approveInsurance(uint index) public view onlyMembers{
        InsurePerson ins = insurance[index];
        require(ins.isBusiness==true);
        require(!ins.passInsurance[msg.sender]); // person has not agreed on insurance


        ins.passInsurance[msg.sender]=true;

        ins.agree++;
    }
    modifier restricted1(){

        require(msg.pubkey() ==tvm.pubkey(),102);
        require(members[msg.sender] ==true);
        require(msg.sender == manager1);
        tvm.accept();
        _;
    }
    function releaseFunds(uint index) public view restricted1{
        InsurePerson ins = insurance[index];
        require(ins.agree >10);
        require(ins.complete == false);
        ins.complete= true;
        string text = "Insured";
        emit LoanApproved(text,ins.amount,now);
    }
    enum ProjectState {Pending, Complete}
    ProjectState state;
    struct Project{
        string description;
        uint128 amount;
        ProjectState condition;
        uint agree;
    }
    Project[] projects;
    function initiateProject(string description,uint128 amount) public onlyMembers returns(Project){
        Project newproject = Project({
            description: description,
            amount:amount,
            condition:ProjectState.Pending,
            agree:0
        });
        projects.push(newproject);
        return newproject;
    }
    function approveProject(uint index) public view onlyMembers{
        Project proj = projects[index];
        proj.agree++;
    }
    function passProjectFunds(uint index) public view onlyMembers{
        Project proj = projects[index];
        InsurePerson ins = insurance[index];
        require(proj.agree >10);
        require(proj.condition == ProjectState.Pending);
        proj.condition = ProjectState.Complete;
        string text = "Project to Implementation.Release money to group leader";
        emit LoanApproved(text,ins.amount,now);
    }
}
